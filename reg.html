<!DOCTYPE html>
<html lang="en">
<head>
    <meta charset="UTF-8">
    <meta name="viewport" content="width=device-width, initial-scale=1.0">
    <title>Registry you can actually query</title>
    <link rel="icon" href="data:image/svg+xml,<svg xmlns='http://www.w3.org/2000/svg' width='32' height='32' viewBox='0 0 32 32'><circle cx='16' cy='16' r='16' fill='%23FF6600'/><text x='16' y='22' font-family='Arial, sans-serif' font-size='20' font-weight='bold' text-anchor='middle' fill='white'>W</text></svg>">
    <link rel="stylesheet" href="styles.css">
    
    <!-- Social Media Preview Meta Tags -->
    <meta property="og:title" content="Registry you can actually query">
    <meta property="og:description" content="Running a private registry is easy; making it searchable isn't. Here's how reg taps SQLite to expose fast queries without touching S3.">
    <meta property="og:image" content="https://writethat.blog/images/reg1.png">
    <meta property="og:type" content="article">
    <meta name="twitter:card" content="summary_large_image">
    <meta name="twitter:title" content="Registry you can actually query">
    <meta name="twitter:description" content="Running a private registry is easy; making it searchable isn't. Here's how reg taps SQLite to expose fast queries without touching S3.">
    <meta name="twitter:image" content="https://writethat.blog/images/reg1.png">
    
    <style>

        h3 {
            color: var(--text-color);
            margin-top: 30px;
        }

        h4 {
            color: var(--text-color);
            margin-top: 25px;
        }

        .article-content ul, .article-content ol {
            margin-bottom: 20px;
            padding-left: 30px;
        }

        .article-content li {
            margin-bottom: 5px;
        }

        .article-content pre {
            background-color: var(--card-bg);
            padding: 15px;
            border-radius: 5px;
            overflow-x: auto;
            font-family: "Consolas", "Monaco", monospace;
            font-size: 0.9em;
            border-left: 4px solid var(--header-bg);
        }

        .article-content code {
            background-color: var(--card-bg);
            padding: 2px 5px;
            border-radius: 3px;
            font-family: "Consolas", "Monaco", monospace;
            font-size: 0.9em;
        }

        .article-content table {
            width: 100%;
            border-collapse: collapse;
            margin: 20px 0;
            font-size: 0.9em;
        }

        .article-content th,
        .article-content td {
            padding: 6px 8px;
            border: 1px solid var(--card-bg);
            text-align: left;
        }

        .article-content th {
            background-color: var(--card-bg);
            text-transform: uppercase;
            font-size: 0.8em;
            letter-spacing: 0.05em;
        }

        .article-content td code {
            background-color: transparent;
            padding: 0;
        }


        @media (max-width: 768px) {
            body {
                overflow-x: hidden;
            }
            .container {
                max-width: 100vw;
                overflow-x: hidden;
            }
            .content {
                padding: 5px !important;
                max-width: 100% !important;
                box-sizing: border-box;
            }
            header {
                padding: 8px;
                margin-bottom: 20px;
                margin-left: 0;
                margin-right: 0;
                box-sizing: border-box;
                max-width: 100%;
                width: 100%;
                overflow: hidden;
            }
            h1 {
                font-size: 1.3em;
                word-wrap: break-word;
                hyphens: auto;
                overflow-wrap: break-word;
                margin: 0;
            }
            .article-content img {
                margin: 10px auto;
                max-width: calc(100vw - 40px);
                width: 100%;
            }
            .article-content pre {
                overflow-x: auto;
                font-size: 0.8em;
            }
            .bonus-section {
                margin: 15px 0;
                padding: 10px;
            }
            .bonus-section h4 {
                margin-left: 25px;
            }
            .bonus-section p {
                margin-left: 25px;
            }
            .bonus-section pre {
                margin-left: 25px;
            }
        }


        .bonus-section {
            background-color: var(--card-bg);
            border: 1px solid var(--header-bg);
            border-radius: 8px;
            padding: 15px;
            margin: 20px 0;
            font-size: 0.9em;
            position: relative;
        }

        .bonus-section::before {
            content: "üí°";
            position: absolute;
            top: 10px;
            left: 10px;
            font-size: 1.2em;
        }

        .bonus-section h4 {
            margin-top: 0;
            margin-left: 30px;
            font-size: 1em;
            color: var(--header-bg);
        }

        .bonus-section p {
            margin-left: 30px;
        }

        .bonus-section pre {
            margin-left: 30px;
        }

        footer {
            margin-top: 40px;
            padding: 20px 0;
            border-top: 1px solid var(--header-bg);
            text-align: center;
            font-size: 0.9em;
            color: var(--text-color);
        }
    </style>
</head>
<body>
    <div class="container">
        <div class="content">
            <a href="index.html" class="back-link">‚Üê writethat.blog</a>
            
            <header>
                <h1>Registry you can actually query</h1>
            </header>

            <div class="article-content">
                <img src="images/reg1.png" alt="Screenshot of reg with logs overlay" />

                <p>Docker registries like <a href="http://docker.io">docker.io</a> and <a href="http://quay.io">quay.io</a> are public endpoints for browsing and fetching OCI images. You can also run a private registry yourself! The registry API is <a href="https://github.com/opencontainers/distribution-spec/blob/main/spec.md">standardized here</a> and the most ubiquitous open-source implementation is <a href="https://github.com/distribution/distribution">available here</a>. Registries can work with myriad data stores, but in practice, they all just run on a comfy and reliable S3-compatible object store. It's cheap, it's persistent, it scales to infinity (if you're willing to renegotiate the "it's cheap" claim), but there's one major flaw. Querying arbitrary information about the stored images (e.g. "list all image repositories in this registry, please") is either:</p><ul><li>painfully slow; or</li><li>painfully unreliable; or</li><li>downright disabled.</li></ul><p>Wouldn't the world be a tad more beautiful if there was a registry you can actually query? Let's implement one!</p><h2>Core API</h2><p>The OCI distribution specification is based on HTTP. It lists all endpoints that a conformant implementation must support, along with their legal methods and status codes for success and failure:</p><table>
    <thead>
        <tr>
            <th>‚Ññ</th>
            <th>Method</th>
            <th>Path</th>
            <th>Success</th>
            <th>Error</th>
        </tr>
    </thead>
    <tbody>
        <tr>
            <td><code>end-1</code></td>
            <td><code>GET</code></td>
            <td><code>/v2/</code></td>
            <td><code>200</code></td>
            <td><code>404/401</code></td>
        </tr>
        <tr>
            <td><code>end-2</code></td>
            <td><code>GET/HEAD</code></td>
            <td><code>/v2/&lt;name&gt;/blobs/&lt;digest&gt;</code></td>
            <td><code>200</code></td>
            <td><code>404</code></td>
        </tr>
        <tr>
            <td><code>end-3</code></td>
            <td><code>GET/HEAD</code></td>
            <td><code>/v2/&lt;name&gt;/manifests/&lt;reference&gt;</code></td>
            <td><code>200</code></td>
            <td><code>404</code></td>
        </tr>
        <tr>
            <td><code>end-4a</code></td>
            <td><code>POST</code></td>
            <td><code>/v2/&lt;name&gt;/blobs/uploads/</code></td>
            <td><code>202</code></td>
            <td><code>404</code></td>
        </tr>
        <tr>
            <td><code>end-4b</code></td>
            <td><code>POST</code></td>
            <td><code>/v2/&lt;name&gt;/blobs/uploads/?digest=&lt;digest&gt;</code></td>
            <td><code>201/202</code></td>
            <td><code>404/400</code></td>
        </tr>
        <tr>
            <td><code>end-5</code></td>
            <td><code>PATCH</code></td>
            <td><code>/v2/&lt;name&gt;/blobs/uploads/&lt;reference&gt;</code></td>
            <td><code>202</code></td>
            <td><code>404/416</code></td>
        </tr>
        <tr>
            <td><code>end-6</code></td>
            <td><code>PUT</code></td>
            <td><code>/v2/&lt;name&gt;/blobs/uploads/&lt;reference&gt;?digest=&lt;digest&gt;</code></td>
            <td><code>201</code></td>
            <td><code>404/400</code></td>
        </tr>
        <tr>
            <td><code>end-7</code></td>
            <td><code>PUT</code></td>
            <td><code>/v2/&lt;name&gt;/manifests/&lt;reference&gt;</code></td>
            <td><code>201</code></td>
            <td><code>404/413</code></td>
        </tr>
        <tr>
            <td><code>end-8a</code></td>
            <td><code>GET</code></td>
            <td><code>/v2/&lt;name&gt;/tags/list</code></td>
            <td><code>200</code></td>
            <td><code>404</code></td>
        </tr>
        <tr>
            <td><code>end-8b</code></td>
            <td><code>GET</code></td>
            <td><code>/v2/&lt;name&gt;/tags/list?n=&lt;integer&gt;&amp;last=&lt;tagname&gt;</code></td>
            <td><code>200</code></td>
            <td><code>404</code></td>
        </tr>
        <tr>
            <td><code>end-9</code></td>
            <td><code>DELETE</code></td>
            <td><code>/v2/&lt;name&gt;/manifests/&lt;reference&gt;</code></td>
            <td><code>202</code></td>
            <td><code>404/400/405</code></td>
        </tr>
        <tr>
            <td><code>end-10</code></td>
            <td><code>DELETE</code></td>
            <td><code>/v2/&lt;name&gt;/blobs/&lt;digest&gt;</code></td>
            <td><code>202</code></td>
            <td><code>404/400/405</code></td>
        </tr>
        <tr>
            <td><code>end-11</code></td>
            <td><code>POST</code></td>
            <td><code>/v2/&lt;name&gt;/blobs/uploads/?mount=&lt;digest&gt;&amp;from=&lt;other_name&gt;</code></td>
            <td><code>201/202</code></td>
            <td><code>404</code></td>
        </tr>
        <tr>
            <td><code>end-12a</code></td>
            <td><code>GET</code></td>
            <td><code>/v2/&lt;name&gt;/referrers/&lt;digest&gt;</code></td>
            <td><code>200</code></td>
            <td><code>404/400</code></td>
        </tr>
        <tr>
            <td><code>end-12b</code></td>
            <td><code>GET</code></td>
            <td><code>/v2/&lt;name&gt;/referrers/&lt;digest&gt;?artifactType=&lt;artifactType&gt;</code></td>
            <td><code>200</code></td>
            <td><code>404/400</code></td>
        </tr>
        <tr>
            <td><code>end-13</code></td>
            <td><code>GET</code></td>
            <td><code>/v2/&lt;name&gt;/blobs/uploads/&lt;reference&gt;</code></td>
            <td><code>204</code></td>
            <td><code>404</code></td>
        </tr>
    </tbody>
</table><p>The REST paths are rather self-descriptive, modulo the cryptic "referrers" with an even more cryptic definition: "a list of manifests with a subject relationship to a specified digest." Let's forget about these for now. The most important part is storing layers (a.k.a. blobs) and all kinds of metadata about images, their layers, versions, tags, etc. I described the OCI image format in more detail <a href="https://writethat.blog/layers.html">in this post</a>.</p><p>How does the official implementation handle all the data management? It can be summed up as "let's squeeze absolutely everything in S3." That applies both to data (OCI layers) and metadata (OCI manifests, tags, uploads, etc). It also makes the registry service extremely lightweight, as it doesn't keep any data itself. It really is barely more than syntactic sugar over the S3 API. The standard also specifies that it's fine to return an HTTP redirect response, which can be used to send presigned S3 requests. Then, users can fetch data from S3 directly. The storage layout is straightforward &ndash; data is kept in one prefix, metadata in another.</p><pre><code>$ aws s3 ls my-fancy-bucket/docker/registry/v2/
                           PRE blobs/          &larr; data goes here
                           PRE repositories/   &larr; metadata goes here</code></pre><p>Simple and brilliant, because everything is stored in a single place with high reliability guarantees. It's also what makes querying so bothersome: most interesting inquiries need to scan a huge S3 bucket. That's inefficient in two important ways: it&rsquo;s slow and it&rsquo;s expensive.</p><p>What if we keep metadata somewhere else? Enter SQLite.</p><h2>Metadata store</h2><p>The OCI distribution format can be translated to a simple SQL schema. It can look roughly like this:</p><pre><code>$ sqlite3 registry.db '.schema'
CREATE TABLE tags (
                        repository TEXT NOT NULL,
                        name TEXT NOT NULL,
                        PRIMARY KEY(repository, name)
                );
CREATE TABLE manifests (
                        tag_rowid INTEGER NOT NULL,
                        manifest_json TEXT NOT NULL,
                        PRIMARY KEY(tag_rowid)
                );
CREATE TABLE manifest_layers (
                        manifest_rowid INTEGER NOT NULL,
                        layer_digest TEXT NOT NULL,
                        layer_index INTEGER NOT NULL,
                        PRIMARY KEY(manifest_rowid, layer_digest, layer_index)
                );
CREATE TABLE layers (
                        digest TEXT PRIMARY KEY,
                        media_type TEXT NOT NULL,
                        size INTEGER NOT NULL
                );
CREATE TABLE upload_sessions (
                        upload_id TEXT PRIMARY KEY,
                        repository TEXT NOT NULL,
                        digest TEXT,
                        s3_upload_id TEXT,
                        s3_key TEXT NOT NULL,
                        total_size INTEGER,
                        uploaded_size INTEGER DEFAULT 0
                );</code></pre><p>Publishing an image boils down to uploading the layers to an object store and updating the metadata:</p><ul><li>which manifest do the layers belong to;</li><li>which repository and image tag does the uploaded manifest describe;</li><li>etc.</li></ul><p>Keeping information in SQLite is easy, because it's just a file. An OCI registry is a distributed system, though, so how can you store everything in a file and pretend it's scalable? A key observation is that we can store metadata in a "write-through" manner. Save everything in SQLite alright, but also store it in S3, just like the original implementation does. You can then treat SQLite as a fast-yet-powerfully-queryable cache.</p><p>What if you lose the file or it becomes corrupt?</p><h3>Bootstrap</h3><p>First of all, since all the metadata is preserved in S3, the registry can scan the whole bucket and recreate the metadata structure in SQLite. That may take a few centuries for a large repository, but is only done sparingly &ndash; ideally once. The ability to bootstrap from an existing object store bucket also makes the registry a "drop-in replacement‚Ñ¢," as tech companies love to describe their products.</p><h3>Turso</h3><p>Now that an SQLite-as-a-Service company (Turso) has entered the market, we can offload the complicated backup and replication bits to them, while still having a simple local file to manage. The <a href="https://docs.turso.tech/features/embedded-replicas/introduction">embedded replicas</a> feature looks relevant.</p><h3>Backup backup ideas</h3><p>An SQLite database is a file, so if you're somehow not enticed by Turso (shame on you), other backup strategies exist. There&rsquo;s "just rsync with cron" and Litestream, to name just two.</p><h2>Metadata insights</h2><p>With all metadata kept locally, we can unleash SQLite's full potential and get all kinds of information from our new store.</p><p>All repositories in the registry, in JSON:</p><pre><code>&gt; select json_group_array(repository) from tags;
["abc","alpine","hello-world","podman-hello","etcd","node-ex
porter","distroless-static","distroless-base","pause","cored
ns","containerbase","nginx","redis","alpine","alpine"] </code></pre><p>Repositories with the most tags:</p>
<pre><code>&gt; select repository, count(name) tags from tags group by repository
    order by tags desc limit 3;
repository     tags
-------------  ----
alpine         3   
abc            1   
containerbase  1 </code></pre>
<p>Largest layers with matching image tags:</p>
<pre><code>select repository, tags.name tag, (size/1024/1024) || ' MiB' size from layers
    join manifest_layers on digest = layer_digest
    join tags on manifest_rowid = tags.rowid
    order by size desc limit 8;
repository     tag       size
-------------  --------  --------
abc            latest    218 MiB                                    
abc            latest    33 MiB                    
containerbase  latest    28 MiB                               
abc            latest    22 MiB                    
nginx          alpine    16 MiB                    
coredns        v1.10.1   15 MiB                    
redis          7-alpine  11 MiB                    
node-exporter  v1.6.1    9 MiB                     </code></pre>
<p>List layers most frequently reused by multiple manifests:</p>
<pre><code>select substr(layer_digest, 8, 8) digest, count(*) reused from manifest_layers
    group by layer_digest order by reused desc limit 3;
digest    reused
--------  ------
e33bce57  2     
b6824ed7  2     
9ef7d74b  2</code></pre><h2>reg</h2><pre><code> $$$$$$\   $$$$$$\   $$$$$$\  
$$  __$$\ $$  __$$\ $$  __$$\ 
$$ |  \__|$$$$$$$$ |$$ /  $$ |
$$ |      $$   ____|$$ |  $$ |
$$ |      \$$$$$$$\ \$$$$$$$ |
\__|       \_______| \____$$ |
                    $$\   $$ |
                    \$$$$$$  |
                     \______/</code></pre><p>I'm a huge fan of concise naming, so this project is codenamed <strong><a href="https://github.com/psarna/reg">reg</a></strong>, and comes with obligatory low effort 3D ASCII art. Contributions are welcome!</p><p>It is still very much a work-in-progress, but it can already:</p><ul><li>Bootstrap itself from S3.</li><li>Properly process uploads (tested locally with min.io).</li><li>Serve image pulls.</li></ul><p>In other words, it's usable enough for local development.</p><h2>Demo</h2><h3>Pushing an image to a local registry</h3><pre><code>$ skopeo copy --dest-no-creds --dest-tls-verify=false docker://alpine:3.23 docker://localhost:2137/alpine:3.23
Getting image source signatures
Copying blob 014e56e61396 skipped: already exists  
Copying config 7acffee03f done   | 
Writing manifest to image destination</code></pre><h3>Logs from a successful push</h3><pre><code>$ go build ./cmd/reg &amp;&amp; AWS_REGION=us-east-1 AWS_PROFILE=minio ./reg serve -b buck
 $$$$$$\   $$$$$$\   $$$$$$\  
$$  __$$\ $$  __$$\ $$  __$$\ 
$$ |  \__|$$$$$$$$ |$$ /  $$ |
$$ |      $$   ____|$$ |  $$ |
$$ |      \$$$$$$$\ \$$$$$$$ |
\__|       \_______| \____$$ |
                    $$\   $$ |
                    \$$$$$$  |
                     \______/ 
Server starting on :2137 with bucket 'buck'...
time=2025-12-17T12:57:50.270+01:00 level=DEBUG msg=getBlob name=alpine blobKey=docker/registry/v2/blobs/sha256/01/014e56e613968f73cce0858124ca5fbc601d7888099969a4eea69f31dcd71a53/data method=HEAD
time=2025-12-17T12:57:50.516+01:00 level=DEBUG msg=getBlob name=alpine blobKey=docker/registry/v2/blobs/sha256/7a/7acffee03fe864cd6b88219a1028855d6c912e7cf6fac633aa4307529fd0cc08/data method=HEAD
time=2025-12-17T12:57:50.540+01:00 level=DEBUG msg=putManifest name=alpine reference=3.23
time=2025-12-17T12:57:50.540+01:00 level=DEBUG msg="putting manifest blob" blobKey=docker/registry/v2/blobs/sha256/a1/a107a3c031732299dd9dd607bb13787834db2de38cfa13f1993b7105e4814c60/data
time=2025-12-17T12:57:50.546+01:00 level=DEBUG msg="putting manifest meta" metaKey=docker/registry/v2/repositories/alpine/_manifests/tags/3.23/current/link
time=2025-12-17T12:57:50.550+01:00 level=DEBUG msg="putting manifest index meta" metaIndexKey=docker/registry/v2/repositories/alpine/_manifests/tags/3.23/index/sha256/a107a3c031732299dd9dd607bb13787834db2de38cfa13f1993b7105e4814c60/link
time=2025-12-17T12:57:50.553+01:00 level=DEBUG msg="putting manifest revisions meta" revisionsKey=docker/registry/v2/repositories/alpine/_manifests/revisions/sha256/a107a3c031732299dd9dd607bb13787834db2de38cfa13f1993b7105e4814c60/link
Put manifest for alpine with reference 3.23</code></pre><h3>Pulling and running a container</h3><pre><code>$ podman run --tls-verify=0 docker://localhost:2137/alpine:3.19 which busybox
Trying to pull localhost:2137/alpine:3.19...
Getting image source signatures
Copying blob 17a39c0ba978 done   | 
Copying config 83b2b6703a done   | 
Writing manifest to image destination
/bin/busybox</code></pre><h3>Logs from a successful pull</h3><pre><code>time=2025-12-17T13:04:33.652+01:00 level=DEBUG msg="Retrieved manifest" repo=alpine tag=3.19
time=2025-12-17T13:04:33.653+01:00 level=DEBUG msg=getBlob name=alpine blobKey=docker/registry/v2/blobs/sha256/83/83b2b6703a620bf2e001ab57f7adc414d891787b3c59859b1b62909e48dd2242/data method=GET
time=2025-12-17T13:04:33.661+01:00 level=DEBUG msg=getBlob name=alpine blobKey=docker/registry/v2/blobs/sha256/17/17a39c0ba978cc27001e9c56a480f98106e1ab74bd56eb302f9fd4cf758ea43f/data method=GET
time=2025-12-17T13:05:39.019+01:00 level=DEBUG msg="Retrieved manifest" repo=alpine tag=3.19
time=2025-12-17T13:05:39.021+01:00 level=DEBUG msg=getBlob name=alpine blobKey=docker/registry/v2/blobs/sha256/83/83b2b6703a620bf2e001ab57f7adc414d891787b3c59859b1b62909e48dd2242/data method=GET
time=2025-12-17T13:05:39.027+01:00 level=DEBUG msg=getBlob name=alpine blobKey=docker/registry/v2/blobs/sha256/17/17a39c0ba978cc27001e9c56a480f98106e1ab74bd56eb302f9fd4cf758ea43f/data method=GET</code></pre><h2>üëã</h2><p>Give it a try! Especially if you also feel like reducing the number of missing features. You might have noticed the glaring <em>--tls-verify=0</em> flag passed in every <em>skopeo</em> command due to reg's inability to speak HTTPS.</p>
            </div>
        </div>
        
        <div class="sidebar">
            <a class="banner" href="https://github.com/scynthiadunlop/WritingForDevelopersBook/" style="text-decoration: none; color: inherit;" target="_blank">
                <aside>
                    <img src="writing.webp" alt="Book cover">
                    <h2>Writing for Developers: Blogs That Get Read</h2>
                    <p>Read our book, it's really fantastic and all!</p>
                    <p><strong>by Piotr Sarna and Cynthia Dunlop</strong></p>
                    <p><em>Available now!</em></p>
                </aside>
            </a>
            <div class="patterns-section">
                <h3>Patterns</h3>
                <ul style="list-style: none; padding: 0; margin: 0;">
                    <li style="margin-bottom: 8px;"><a href="?pattern=bug hunt" class="pattern-link">Bug Hunt</a></li>
                    <li style="margin-bottom: 8px;"><a href="?pattern=we rewrote it in X" class="pattern-link">We Rewrote It in X</a></li>
                    <li style="margin-bottom: 8px;"><a href="?pattern=how we built it" class="pattern-link">How We Built It</a></li>
                    <li style="margin-bottom: 8px;"><a href="?pattern=lessons learned" class="pattern-link">Lessons Learned</a></li>
                    <li style="margin-bottom: 8px;"><a href="?pattern=thoughts on trends" class="pattern-link">Thoughts on Trends</a></li>
                    <li style="margin-bottom: 8px;"><a href="?pattern=non-markety product perspectives" class="pattern-link">Non-markety Product Perspectives</a></li>
                    <li style="margin-bottom: 8px;"><a href="?pattern=benchmarks and test results" class="pattern-link">Benchmarks and Test Results</a></li>
                </ul>
            </div>
            <div class="patterns-section" style="margin-top: 20px;">
                <h3>Posts</h3>
                <ul style="list-style: none; padding: 0; margin: 0;">
                    <li style="margin-bottom: 8px;"><a href="reg.html" class="pattern-link">Registry you can actually query</a></li>
                    <li style="margin-bottom: 8px;"><a href="intercom.html" class="pattern-link">Grant your intercom WiFi superpowers for $8</a></li>
                    <li style="margin-bottom: 8px;"><a href="layers.html" class="pattern-link">Thinning layers</a></li>
                </ul>
            </div>
        </div>
    </div>
</body>
</html>
